/*
? The default constructor takes no arguements. If class creator doesn't create any constructor, then compiler generates a default constructor. It is called default default constructor. It is created when there is no constructor.

    class Point{
        public:
            Point();
            ! Point() = default;
            Point(int=0, int=0);! Constructor with default values
        private:
            int m_x, m_y;
            ! m_x{}, m_y{};         Attributes are initialized to zero.
    };

    Point::Point() : m_x{}, m_y{} {}

    int main() {
        Point array[5] = {10, 20, {}, {30, 49}}; ! It is valid
        Point array[5] = {10, 20, , {30, 49}};   ! It is not valid
    }


? Member initializer list is used to initialize const members. It can be used to initialize other non-constant members.
! The member initializer initialize a member as it is created. If you use assignment statement to initialize a member, first the member is created, then the value assigns to the member. It can be more efficient to use member initializer list.

    class Point{
        private:
            const int MIN_x, MIN_y;
            int m_x, m_y;
        public:
            Point(int, int, int, int);
    };
    Point::Point(int firstMINX, int firstMINY, int firstX, int firstY) : MIN_x {firstMINX}, MIN_y {firstMINY}, m_x {firstX}, m_y {firstY};


? Any member variable of a const object is itself a const variable and thus immutable. 
? Defining member functions as const if they do not change any member attributes to avoid possible errors. 
! A const method can call only other const methods, and non-const method can call only non-const methods.
? If any class member defined as mutable, then the const function can change its value although it is a const function member.


    class Point{
        private:
            int m_x, m_y;
            mutable unsigned int m_printCount{};
            some other attributes
        public:
            Point(int, int);
            int getX() const { return m_x; }
            int getY() const { return m_y; }
            bool move(int, int);
            void print() const;
    };

    void Point::print() const {
        std::cout << "X= " << m_x << " Y= " << m_y;
        std::cout << "Print count= " << ++m_printCount;  print is a const member function but it can change the mutable variable.
    }


? The copy constructor is used if a new object is created as a copy of an existing object. 
! Most of the time we use the copy constructer generated by compiler, but this constructor copies the contents of the original object to new one. If we don't want to copy all contents of the original object, then we have to write our own copy constructor.
! If a class has a member variable of a pointer type, then we must write our own copy constructor, because the compiler generated one copies that pointer address to new object's pointer. We want only its content, not address.


    class String{
        private:
            size_t m_size;
            char *m_contents;
        public:
            String(const char*);
            String(const String&);          ! copy constructor
            String(const String&) = delete; ! If we don't want any copy constructor, then we can prevent it like that.
    };

    String::String(const String& originalString) {
        m_size = originalString.m_size;
        m_contents = new char[m_size+1];
        if (m_contents) {
            for (std::size_t index = 0; index < m_size+1; index++) {
                m_contents[index] = originalString.m_contents[index];
            }
        }
    }

    int main() {
        String originalString{"harun"};
        String copyString{originalString};
        String otherString = originalString; ! Another notation, not assignment
    }



! When passing objects as an argument, it is more efficient to use call by reference.

? Each object of a class has its own copy of the ordinary data members. If you declare a member as static, the static member defined only once, regardless of how many class objects have been defined.
? The static members exist, and the public static methods can be called even if no class objects have been created. We can directly change the static data member using static method, regardless of whether an objects is created.


    class Point{
        public:
            .......
            static inline const int MIN_x{}, MIN_y{};
        private:
            int m_x{}, m_y{};  
            static inline int s_point_count{};
            static void initPointCount(int);
    };
*/